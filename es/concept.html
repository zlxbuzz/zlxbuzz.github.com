<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>闭包 | 总结</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.10.0/styles/monokai-sublime.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/github-markdown-css/2.9.0/github-markdown.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css">
    <script src="//cdn.bootcss.com/ace/1.3.3/ace.js"></script>
    <script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="//cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=default"></script>
    <meta name="description" content="前端总结">
    
    <link rel="preload" href="/assets/css/0.styles.9bdba38b.css" as="style"><link rel="preload" href="/assets/js/app.e6fff1ef.js" as="script"><link rel="preload" href="/assets/js/2.c89a1be6.js" as="script"><link rel="preload" href="/assets/js/1.f08d8127.js" as="script"><link rel="preload" href="/assets/js/45.feb9d736.js" as="script"><link rel="prefetch" href="/assets/js/10.2e4bc1e7.js"><link rel="prefetch" href="/assets/js/100.8b63e916.js"><link rel="prefetch" href="/assets/js/101.f6d5eff1.js"><link rel="prefetch" href="/assets/js/102.9ab3f8b0.js"><link rel="prefetch" href="/assets/js/103.af218052.js"><link rel="prefetch" href="/assets/js/104.d7dfc521.js"><link rel="prefetch" href="/assets/js/105.4610fd83.js"><link rel="prefetch" href="/assets/js/106.8a44e851.js"><link rel="prefetch" href="/assets/js/107.7e4bca3f.js"><link rel="prefetch" href="/assets/js/108.8c85ae89.js"><link rel="prefetch" href="/assets/js/109.9de6d07f.js"><link rel="prefetch" href="/assets/js/11.5384b140.js"><link rel="prefetch" href="/assets/js/110.96d23754.js"><link rel="prefetch" href="/assets/js/111.7a2bfee2.js"><link rel="prefetch" href="/assets/js/112.e7a9487a.js"><link rel="prefetch" href="/assets/js/113.263468d2.js"><link rel="prefetch" href="/assets/js/114.eced8df8.js"><link rel="prefetch" href="/assets/js/115.2f20aa85.js"><link rel="prefetch" href="/assets/js/12.c8691c9b.js"><link rel="prefetch" href="/assets/js/13.8a85afa6.js"><link rel="prefetch" href="/assets/js/14.c60b02ec.js"><link rel="prefetch" href="/assets/js/15.d6431719.js"><link rel="prefetch" href="/assets/js/16.344ff5e6.js"><link rel="prefetch" href="/assets/js/17.8dd2e427.js"><link rel="prefetch" href="/assets/js/18.02f7391a.js"><link rel="prefetch" href="/assets/js/19.45ab1a6d.js"><link rel="prefetch" href="/assets/js/20.bdbd260c.js"><link rel="prefetch" href="/assets/js/21.814c6fa6.js"><link rel="prefetch" href="/assets/js/22.3baba8f6.js"><link rel="prefetch" href="/assets/js/23.77d48783.js"><link rel="prefetch" href="/assets/js/24.39298b94.js"><link rel="prefetch" href="/assets/js/25.c2361335.js"><link rel="prefetch" href="/assets/js/26.e69dc1c4.js"><link rel="prefetch" href="/assets/js/27.4f80f343.js"><link rel="prefetch" href="/assets/js/28.3ce358e7.js"><link rel="prefetch" href="/assets/js/29.29ea6c10.js"><link rel="prefetch" href="/assets/js/3.4a44afe3.js"><link rel="prefetch" href="/assets/js/30.ecc277f0.js"><link rel="prefetch" href="/assets/js/31.dce180b1.js"><link rel="prefetch" href="/assets/js/32.c9d98a70.js"><link rel="prefetch" href="/assets/js/33.b154a82a.js"><link rel="prefetch" href="/assets/js/34.1e27b412.js"><link rel="prefetch" href="/assets/js/35.ccb19b67.js"><link rel="prefetch" href="/assets/js/36.71c5b729.js"><link rel="prefetch" href="/assets/js/37.48502ea1.js"><link rel="prefetch" href="/assets/js/38.1025f787.js"><link rel="prefetch" href="/assets/js/39.9f633672.js"><link rel="prefetch" href="/assets/js/4.d91e2a54.js"><link rel="prefetch" href="/assets/js/40.51f250f6.js"><link rel="prefetch" href="/assets/js/41.691adf38.js"><link rel="prefetch" href="/assets/js/42.07eab90e.js"><link rel="prefetch" href="/assets/js/43.772c0f25.js"><link rel="prefetch" href="/assets/js/44.de1298a4.js"><link rel="prefetch" href="/assets/js/46.cdb75989.js"><link rel="prefetch" href="/assets/js/47.f72df5b3.js"><link rel="prefetch" href="/assets/js/48.8b70a226.js"><link rel="prefetch" href="/assets/js/49.5d2c0200.js"><link rel="prefetch" href="/assets/js/5.8dcd1f8f.js"><link rel="prefetch" href="/assets/js/50.8a26fd6f.js"><link rel="prefetch" href="/assets/js/51.a614a1bb.js"><link rel="prefetch" href="/assets/js/52.b3d21eea.js"><link rel="prefetch" href="/assets/js/53.618a7916.js"><link rel="prefetch" href="/assets/js/54.59406918.js"><link rel="prefetch" href="/assets/js/55.2c02f3a8.js"><link rel="prefetch" href="/assets/js/56.9534a573.js"><link rel="prefetch" href="/assets/js/57.5fe10564.js"><link rel="prefetch" href="/assets/js/58.33dabce7.js"><link rel="prefetch" href="/assets/js/59.717da3d2.js"><link rel="prefetch" href="/assets/js/6.4b73bb31.js"><link rel="prefetch" href="/assets/js/60.3989838e.js"><link rel="prefetch" href="/assets/js/61.16ab584f.js"><link rel="prefetch" href="/assets/js/62.92f859fb.js"><link rel="prefetch" href="/assets/js/63.90cfd883.js"><link rel="prefetch" href="/assets/js/64.8f3bbf63.js"><link rel="prefetch" href="/assets/js/65.b6223542.js"><link rel="prefetch" href="/assets/js/66.e7fa6a54.js"><link rel="prefetch" href="/assets/js/67.baccd837.js"><link rel="prefetch" href="/assets/js/68.a8b6a4bd.js"><link rel="prefetch" href="/assets/js/69.db67ad7b.js"><link rel="prefetch" href="/assets/js/7.c934174c.js"><link rel="prefetch" href="/assets/js/70.208ab3c2.js"><link rel="prefetch" href="/assets/js/71.8212dfcb.js"><link rel="prefetch" href="/assets/js/72.8bb63684.js"><link rel="prefetch" href="/assets/js/73.a681d42a.js"><link rel="prefetch" href="/assets/js/74.41f02ae3.js"><link rel="prefetch" href="/assets/js/75.0c29b574.js"><link rel="prefetch" href="/assets/js/76.b2bb0343.js"><link rel="prefetch" href="/assets/js/77.25de8167.js"><link rel="prefetch" href="/assets/js/78.9405b4c9.js"><link rel="prefetch" href="/assets/js/79.d430a3a1.js"><link rel="prefetch" href="/assets/js/80.da8b8316.js"><link rel="prefetch" href="/assets/js/81.a8ef0056.js"><link rel="prefetch" href="/assets/js/82.53493829.js"><link rel="prefetch" href="/assets/js/83.5c828e18.js"><link rel="prefetch" href="/assets/js/84.d717a61c.js"><link rel="prefetch" href="/assets/js/85.6cb3f209.js"><link rel="prefetch" href="/assets/js/86.634db20d.js"><link rel="prefetch" href="/assets/js/87.9a9c281c.js"><link rel="prefetch" href="/assets/js/88.3e71673f.js"><link rel="prefetch" href="/assets/js/89.ab95b51f.js"><link rel="prefetch" href="/assets/js/90.b6832bd7.js"><link rel="prefetch" href="/assets/js/91.270d1704.js"><link rel="prefetch" href="/assets/js/92.97e20606.js"><link rel="prefetch" href="/assets/js/93.5c70cb52.js"><link rel="prefetch" href="/assets/js/94.ac6db360.js"><link rel="prefetch" href="/assets/js/95.dd4c86f9.js"><link rel="prefetch" href="/assets/js/96.c4edd584.js"><link rel="prefetch" href="/assets/js/97.e27eec26.js"><link rel="prefetch" href="/assets/js/98.b27047fc.js"><link rel="prefetch" href="/assets/js/99.3d766fb1.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.857e8e87.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9bdba38b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">总结</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/es/" class="nav-link router-link-active">
  JS
</a></div><div class="nav-item"><a href="/html/" class="nav-link">
  HTML
</a></div><div class="nav-item"><a href="/framework/" class="nav-link">
  框架
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试总结
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="源码学习" class="dropdown-title"><span class="title">源码学习</span> <span class="arrow down"></span></button> <button type="button" aria-label="源码学习" class="mobile-dropdown-title"><span class="title">源码学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/source/vue/" class="nav-link">
  Vue2源码
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/es/" class="nav-link router-link-active">
  JS
</a></div><div class="nav-item"><a href="/html/" class="nav-link">
  HTML
</a></div><div class="nav-item"><a href="/framework/" class="nav-link">
  框架
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试总结
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="源码学习" class="dropdown-title"><span class="title">源码学习</span> <span class="arrow down"></span></button> <button type="button" aria-label="源码学习" class="mobile-dropdown-title"><span class="title">源码学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/source/vue/" class="nav-link">
  Vue2源码
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/es/this.html" class="sidebar-link">this</a></li><li><a href="/es/prototype.html" class="sidebar-link">原型</a></li><li><a href="/es/function.html" class="sidebar-link">函数</a></li><li><a href="/es/hand.html" class="sidebar-link">手写代码</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <ol><li>广义的来说闭包就是函数，所有函数都是闭包。2. 狭义来说可以访问其他函数内部变量的函数，统称为闭包。函数+可访问的外部变量 = 闭包</li> <li>一般我们在函数内部定义新函数，这个新函数可以访问到外层的变量和参数，这些变量和参数不会随着函数的执行完毕而销毁，这个新函数和外部的变量参数统称为闭包。</li></ol> <p>优点：缓存变量，进行封装。
缺点：内存过大，内存泄漏。
例子：防抖,操作私有变量</p> <h2 id="类型"><a href="#类型" class="header-anchor">#</a> 类型</h2> <p>1.如果加号两边都是 Number 类型,规则为：
如果 + 号两边存在 NaN，则结果为 NaN（typeof NaN 是 ‘number’）
如果是 Infinity + (-Infinity)，结果是 NaN
其余为正常计算</p> <p>2.如果加号两边有至少一个是字符串，其规则为：
如果 + 号两边都是字符串，则执行字符串拼接
如果 + 号两边只有一个值是字符串，则将另外的值转换为字符串，再执行字符串拼接
如果 + 号两边有一个是对象，则调用 valueof() 或者 toString() 方法取得值，转换为基本类型再进行字符串拼接。
具体调用 valueOf 还是 toString ？根据 ES 规范所决定的，实际上这取决于内置的 toPrimitive 调用结果</p> <h2 id="this-指向"><a href="#this-指向" class="header-anchor">#</a> this 指向</h2> <ol><li>简单函数调用，一般为 window/global，严格模式为 undefined</li> <li>new 调用构造函数，指向新的对象( 如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例。
)</li> <li>call/apply/bind,指向传入的参数对象</li> <li>上下文对象调用，指向该对象</li> <li>箭头函数指向外层的上下文绑定，且不能改变</li></ol> <h2 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h2> <p>作用域是指代码中定义变量的区域</p> <p>JavaScript 采用的是静态作用域,也叫做词法作用域，在函数定义的时候就确定了作用域</p> <p>暂时性死区 TDZ: 在函数开始到变量声明中间，为 TDZ，即不能访问 let 或者 const 声明的变量,在全局作用域，不存在变量提升；在块级作用域，存在变量的创建提升</p> <p>代码遇到全局，函数，eval 的时候，均会做准备工作，即执行上下文</p> <p>作用域是静态的，执行上下文是动态的</p> <div class="language- extra-class"><pre class="language-text"><code>执行上下文栈（Execution context stack，ECS）来管理执行上下文
ECStack = []


// 全局的执行上下文
ECStack = [
	globalContext
]

// 函数执行上下文

ECStack = [
	fnContext,
]





# 当某个函数被调用时，会创建一个执行环境（execution context）和相应的作用域链(scope chain),每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中

执行上下文包含：当前代码的执行环境(函数或全局)也就是作用域链,变量对象(声明参数，声明函数，接收参数，自由变量(在函数中使用，同时既不是函数参数也不是函数的局部变量)，arguments)，this
ExecutionContext = {
    variableObject: { .... },
    this: thisValue, Scope: [ // Scope chain
      // 所有变量对象的列表
    ]
};

</code></pre></div><p>执行上下文周期：</p> <p>1.创建:生成变量对象，建立作用域链(包含作用域链)，确定 this 指向</p> <p>2.执行:变量赋值，函数引用，执行代码等</p> <p>3.销毁</p> <div class="language-demo extra-class"><pre class="language-text"><code>var scope = &quot;global scope&quot;;
function checkscope(){
    var scope = &quot;local scope&quot;;
    function f(){
        return scope;
    }
    return f();
}
checkscope();
1、执行全局代码，生成全局上下文，并且压入执行栈
ECStack=[
     globalContext
]
2、全局上下文初始化
globalContext={
     variableObject:[global,scope,checkscope],
     this:globalContext.variableObject,
     scopeChain:[globalContext.variableObject]
}
3、创建 checkscope 函数时生成内部属性 [[scope]],并将全局上下文作用域链存入其中
checkscope.[[scope]] = [
     globalContext.variableObject
]
4、调用 checkscope 函数，创建函数上下文，压栈
ECStack=[
     globalContext,
     checkscopeContext
]
5、此时 checkscope 函数还未执行，进入执行上下文

复制函数 [[scope]] 属性创建作用域链
用 arguments 属性创建活动对象
初始化变量对象，加入变量声明、函数声明、形参
活动对象压入作用域链顶端

    checkscopeContext = {
        activationObject: {
            arguments: {
                length: 0
            },
            scope: undefined,
            f: pointer, // reference to function f(),
        },
        scopeChain: [activationObject, globalContext.variableObject],
        this: undefined
    }
6、checkscope 函数执行，对变量 scope 设值
    checkscopeContext = {
        activationObject: {
            arguments: {
                length: 0
            },
            scope: 'local scope',
            f: pointer, // reference to function f(),
        },
        scopeChain: [activationObject, globalContext.variableObject],
        this: undefined
    }
f 函数被创建生成 [[scope]] 属性，并保存父作用域的作用域链
f.[[scope]]=[
     checkscopeContext.activationObject,
     globalContext.variableObject
]
7、f 函数调用，生成 f 函数上下文，压栈
ECStack=[
     globalContext,
     checkscopeContext,
     fContext
]
8、此时 f 函数还未执行，初始化执行上下文

复制函数 [[scope]] 属性创建作用域链
用 arguments 属性创建活动对象
初始化变量对象，加入变量声明、函数声明、形参
活动对象压入作用域链顶端

fContext = {
     activationObject: {
            arguments: {
                length: 0
            },
        },
        scopeChain: [fContext.activationObject, checkscopeContext.activationObject, globalContext.variableObject],
        this: undefined
    }
9、f 函数执行，沿着作用域链查找 scope 值，返回 scope 值
10、f 函数执行完毕，f函数上下文从执行上下文栈中弹出
ECStack=[
     globalContext,
     checkscopeContext
]
11、checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
ECStack=[
     globalContext
]


</code></pre></div><p>ps1: 进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
ps2: 变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作，可以认为同一个对象的不同生命周期。AO = VO + function parameters + arguments</p> <p>代码执行两个阶段：代码预编译(确定作用域,创建 vo 变量对象)，代码执行(确定作用域链,vo-&gt;ao 激活对象)</p> <p>柯里化:使用多层嵌套的闭包，为了参数的累加和延迟调用</p> <p>调用栈：一个个的函数调用</p> <p>闭包：外部环境可以访问内部函数的变量,使其不被销毁</p> <p>内存管理：分配内存，使用内存，释放内存</p> <p>垃圾回收：标记清除，引用计数</p> <h2 id="es5-中的上下文"><a href="#es5-中的上下文" class="header-anchor">#</a> es5 中的上下文</h2> <p>ES5 规范去除了 ES3 中变量对象和活动对象，以 词法环境组件（ LexicalEnvironment component） 和 变量环境组件（ VariableEnvironment component） 替代</p> <h4 id="创建阶段"><a href="#创建阶段" class="header-anchor">#</a> 创建阶段</h4> <p>1.确定 this 的值，也被称为 This Binding</p> <p>2.LexicalEnvironment（词法环境） 组件被创建</p> <p>3.VariableEnvironment（变量环境） 组件被创建</p> <p>创建全局上下文的词法环境使用 对象环境记录器 ,outer 值为 null;
创建函数上下文的词法环境时使用 声明式环境记录器 ,outer 值为全局对象，或者为父级词法环境（作用域）</p> <h2 id="对象和函数"><a href="#对象和函数" class="header-anchor">#</a> 对象和函数</h2> <p>1.对象都是由函数创建的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 仅仅是语法糖</span>
类似于<span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 也是语法趟</span>
等价于<span class="token punctuation">;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>2.函数是一种对象</p> <p>3.prototype
每个函数都有一个默认属性<code>prototype</code>,它的值是一个对象('指向原型'而不是'原型')，默认只有一个属性 <code>constructor</code> 指向函数自身</p> <p>4.<code>__proto__</code>
每一个对象都有一个属性<code>__proto__</code>，指向创建这个对象的函数的 <code>prototype</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 构造函数的prototype和基于该构造函数的实例的`__proto__`都指向实例原型</span>
obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre></div><p>函数的<code>prototype</code>也是对象，也有对应的<code>__proto__</code>,所有的对象都会指向 Object.prototype,Object.prototype.<strong>proto</strong>指向 null
函数也是对象，也有<code>__proto__</code>.比如 Object，Array 等函数，都是由 Function 创建的，自然指向 Function.prototype
比较特殊的：
Function.<strong>proto</strong>===Function.prototype</p> <p>5.Instanceof 的判断队则是：沿着 A 的<strong>proto</strong>这条线来找，同时沿着 B 的 prototype 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 true。如果找到终点还未重合，则返回 false</p> <h2 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h2> <p>函数创建的时候，会有一个内部属性[[scope]],包含了所有的父级变量对象</p> <p>1.执行函数的时候，会先做一步准备，复制[[scope]]的属性创建作用域链</p> <div class="language-js extra-class"><pre class="language-js"><code>fnContext <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">Scope</span><span class="token operator">:</span> fnscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2.创建活动对象，加入形参，函数声明，变量声明</p> <div class="language-js extra-class"><pre class="language-js"><code>fnContext <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token constant">AO</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token literal-property property">arguments</span><span class="token operator">:</span><span class="token punctuation">{</span>
      <span class="token literal-property property">length</span><span class="token operator">:</span><span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">scope</span><span class="token operator">:</span><span class="token keyword">undefined</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">Scope</span><span class="token operator">:</span> fnscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3.将活动对象压入作用域顶端</p> <div class="language-js extra-class"><pre class="language-js"><code>fnContext <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token literal-property property">arguments</span><span class="token operator">:</span> <span class="token punctuation">{</span>
			<span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">0</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token literal-property property">scope</span><span class="token operator">:</span> <span class="token keyword">undefined</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token literal-property property">Scope</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>4.执行函数，更新 ao 的值</p> <div class="language-js extra-class"><pre class="language-js"><code>fnContext <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token constant">AO</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token literal-property property">arguments</span><span class="token operator">:</span><span class="token punctuation">{</span>
      <span class="token literal-property property">length</span><span class="token operator">:</span><span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">scope</span><span class="token operator">:</span><span class="token keyword">undefined</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">Scope</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>5.函数执行完毕上下文弹出</p> <h2 id="任务"><a href="#任务" class="header-anchor">#</a> 任务</h2> <p>同步任务：主线程执行栈
异步任务：进入任务队列，不会立即执行</p> <p>异步任务分为宏任务(macrotask)和微任务(microtask)</p> <h4 id="宏任务"><a href="#宏任务" class="header-anchor">#</a> 宏任务：</h4> <p>setTimeout(x 秒后放入宏任务队列)
setInterval
I/O
事件
postMessage
setImmediate (Node.js，浏览器端该 API 已经废弃)
requestAnimationFrame
UI 渲染</p> <h4 id="微任务"><a href="#微任务" class="header-anchor">#</a> 微任务：</h4> <p>Promise.then
MutationObserver
process.nextTick (Node.js)</p> <p>每次主线程任务执行完毕后，会处理微任务队列，之后在处理宏任务队列</p> <h4 id="new"><a href="#new" class="header-anchor">#</a> new</h4> <p>1.创建空对象 2.将空对象的<strong>proto</strong>指向构造函数的 prototype 3.将空对象赋值给构造函数内部的 this，并执行构造函数逻辑 4.返回第一步创建的对象或者构造函数的显式返回值</p> <p>o=new Constructor
等价于
o = Object.create(Constructor.prototype);</p> <h4 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h4> <p>原型继承，构造函数继承，组合继承，寄生组合继承等</p> <h4 id="高阶函数"><a href="#高阶函数" class="header-anchor">#</a> 高阶函数</h4> <ol><li><p>函数作为参数</p></li> <li><p>函数作为返回值</p></li></ol> <h4 id="纯函数"><a href="#纯函数" class="header-anchor">#</a> 纯函数</h4> <p>必须有参数输入，相同的输入始终为相同的输出,且没有副作用。</p> <p>优点：</p> <ol><li>可缓存数据</li> <li>可测试</li> <li>并行处理</li></ol> <p>副作用：函数依赖外部的状态</p> <ol><li>配置</li> <li>数据库</li> <li>用户输入</li></ol> <h4 id="柯里化"><a href="#柯里化" class="header-anchor">#</a> 柯里化</h4> <p>当一个函数有多个参数时，先传递一部分参数调用，然后返回一个新的函数接受剩余的参数，返回结果</p> <h4 id="pointfree-模式"><a href="#pointfree-模式" class="header-anchor">#</a> PointFree 模式</h4> <p>一种函数式编程的模式</p> <ol><li>不需要指定处理的数据</li> <li>只需要合成运算过程(函数组合)</li> <li>需要定义一些辅助的基本运算函数</li></ol> <h4 id="functor-函子"><a href="#functor-函子" class="header-anchor">#</a> Functor 函子</h4> <p>特殊的容器，通过一个普通的对象来实现，该对象有 map 方法，可以允许一个函数对值进行处理</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e6fff1ef.js" defer></script><script src="/assets/js/2.c89a1be6.js" defer></script><script src="/assets/js/1.f08d8127.js" defer></script><script src="/assets/js/45.feb9d736.js" defer></script>
  </body>
</html>
