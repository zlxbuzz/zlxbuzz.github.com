(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{407:function(a,t,s){"use strict";s.r(t);var r=s(10),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"算法学习"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法学习"}},[a._v("#")]),a._v(" 算法学习")]),a._v(" "),t("h3",{attrs:{id:"二分算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二分算法"}},[a._v("#")]),a._v(" 二分算法")]),a._v(" "),t("p",[a._v("输入必须有序: 对于包含 n 个元素的列表，采用二分法最多需要 log2 n 步，简单查找需要 n 步.")]),a._v(" "),t("p",[a._v("用大 O 表示法来表示：括号内为操作数，指出了算法运行时间的增速,代表最糟糕情况。大 O 表示法会省略常量数字\n二分查找: O(log n)\n简单查找：O(n)\n快排: O(n * log n)\n选择排序: O(n x n)\n旅行商问题: O(n!)")]),a._v(" "),t("h2",{attrs:{id:"选择排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[a._v("#")]),a._v(" 选择排序")]),a._v(" "),t("h4",{attrs:{id:"数组-读取操作有优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组-读取操作有优势"}},[a._v("#")]),a._v(" 数组: 读取操作有优势")]),a._v(" "),t("h4",{attrs:{id:"链表-插入元素有优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表-插入元素有优势"}},[a._v("#")]),a._v(" 链表：插入元素有优势")]),a._v(" "),t("h2",{attrs:{id:"递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[a._v("#")]),a._v(" 递归")]),a._v(" "),t("p",[a._v("在性能上递归可能没有循环好，但是更加容易理解")]),a._v(" "),t("p",[a._v("递归包含：基线条件（函数不调用自己）和递归条件（函数调用自己）")]),a._v(" "),t("p",[a._v("时间复杂度： 递归的次数 * 每次递归中的操作次数")]),a._v(" "),t("h2",{attrs:{id:"快速排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[a._v("#")]),a._v(" 快速排序")]),a._v(" "),t("p",[a._v("实现快速排序时，随机地选择用作基准值的元素。快速排序的平均运行时间为 O(n log n)")]),a._v(" "),t("h2",{attrs:{id:"图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[a._v("#")]),a._v(" 图")]),a._v(" "),t("p",[a._v("图模拟一组连接，由节点和边组成，一个节点可能由多个边。")]),a._v(" "),t("h4",{attrs:{id:"广度优先搜索"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索"}},[a._v("#")]),a._v(" 广度优先搜索")]),a._v(" "),t("p",[a._v("用于图的，解决最短路径问题的算法被称为广度优先搜索,先查找一度关系，在查找二度关系，以此类推。运行时间为 O(节点数+边数) O(V+E)")]),a._v(" "),t("h4",{attrs:{id:"树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[a._v("#")]),a._v(" 树")]),a._v(" "),t("p",[a._v("树是一种特殊的图，没有往后指的边")]),a._v(" "),t("h4",{attrs:{id:"狄克斯特拉算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#狄克斯特拉算法"}},[a._v("#")]),a._v(" 狄克斯特拉算法")]),a._v(" "),t("p",[a._v("找出最快的路径,也就是总权重最小的路径（而非段数最少的路径）,只适用于有向无环图\n(1) 找出最便宜的节点，即可在最短时间内前往的节点。")]),a._v(" "),t("p",[a._v("(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。")]),a._v(" "),t("p",[a._v("(3) 重复这个过程，直到对图中的每个节点都这样做了。")]),a._v(" "),t("p",[a._v("(4) 计算最终路径。")]),a._v(" "),t("p",[a._v("带权重的图也叫做加权图\n如果有负权重，则需要用贝尔曼福德算法")]),a._v(" "),t("h4",{attrs:{id:"贪婪算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪婪算法"}},[a._v("#")]),a._v(" 贪婪算法")]),a._v(" "),t("p",[a._v("并集：集合合并\n交集：共有的元素\n差集：从一个集合剔除另一个集合的元素")]),a._v(" "),t("h4",{attrs:{id:"动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[a._v("#")]),a._v(" 动态规划")]),a._v(" "),t("p",[a._v("先解决子问题，在逐步解决大问题")])])}),[],!1,null,null,null);t.default=v.exports}}]);