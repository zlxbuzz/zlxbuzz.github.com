(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{339:function(t,a,n){"use strict";n.r(a);var s=n(10),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("ol",[a("li",[t._v("广义的来说闭包就是函数，所有函数都是闭包。2. 狭义来说可以访问其他函数内部变量的函数，统称为闭包。函数+可访问的外部变量 = 闭包")]),t._v(" "),a("li",[t._v("一般我们在函数内部定义新函数，这个新函数可以访问到外层的变量和参数，这些变量和参数不会随着函数的执行完毕而销毁，这个新函数和外部的变量参数统称为闭包。")])]),t._v(" "),a("p",[t._v("优点：缓存变量，进行封装。\n缺点：内存过大，内存泄漏。\n例子：防抖,操作私有变量")]),t._v(" "),a("h2",{attrs:{id:"类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[t._v("#")]),t._v(" 类型")]),t._v(" "),a("p",[t._v("1.如果加号两边都是 Number 类型,规则为：\n如果 + 号两边存在 NaN，则结果为 NaN（typeof NaN 是 ‘number’）\n如果是 Infinity + (-Infinity)，结果是 NaN\n其余为正常计算")]),t._v(" "),a("p",[t._v("2.如果加号两边有至少一个是字符串，其规则为：\n如果 + 号两边都是字符串，则执行字符串拼接\n如果 + 号两边只有一个值是字符串，则将另外的值转换为字符串，再执行字符串拼接\n如果 + 号两边有一个是对象，则调用 valueof() 或者 toString() 方法取得值，转换为基本类型再进行字符串拼接。\n具体调用 valueOf 还是 toString ？根据 ES 规范所决定的，实际上这取决于内置的 toPrimitive 调用结果")]),t._v(" "),a("h2",{attrs:{id:"this-指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this-指向"}},[t._v("#")]),t._v(" this 指向")]),t._v(" "),a("ol",[a("li",[t._v("简单函数调用，一般为 window/global，严格模式为 undefined")]),t._v(" "),a("li",[t._v("new 调用构造函数，指向新的对象( 如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例。\n)")]),t._v(" "),a("li",[t._v("call/apply/bind,指向传入的参数对象")]),t._v(" "),a("li",[t._v("上下文对象调用，指向该对象")]),t._v(" "),a("li",[t._v("箭头函数指向外层的上下文绑定，且不能改变")])]),t._v(" "),a("h2",{attrs:{id:"作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),a("p",[t._v("作用域是指代码中定义变量的区域")]),t._v(" "),a("p",[t._v("JavaScript 采用的是静态作用域,也叫做词法作用域，在函数定义的时候就确定了作用域")]),t._v(" "),a("p",[t._v("暂时性死区 TDZ: 在函数开始到变量声明中间，为 TDZ，即不能访问 let 或者 const 声明的变量,在全局作用域，不存在变量提升；在块级作用域，存在变量的创建提升")]),t._v(" "),a("p",[t._v("代码遇到全局，函数，eval 的时候，均会做准备工作，即执行上下文")]),t._v(" "),a("p",[t._v("作用域是静态的，执行上下文是动态的")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("执行上下文栈（Execution context stack，ECS）来管理执行上下文\nECStack = []\n\n\n// 全局的执行上下文\nECStack = [\n\tglobalContext\n]\n\n// 函数执行上下文\n\nECStack = [\n\tfnContext,\n]\n\n\n\n\n\n# 当某个函数被调用时，会创建一个执行环境（execution context）和相应的作用域链(scope chain),每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中\n\n执行上下文包含：当前代码的执行环境(函数或全局)也就是作用域链,变量对象(声明参数，声明函数，接收参数，自由变量(在函数中使用，同时既不是函数参数也不是函数的局部变量)，arguments)，this\nExecutionContext = {\n    variableObject: { .... },\n    this: thisValue, Scope: [ // Scope chain\n      // 所有变量对象的列表\n    ]\n};\n\n")])])]),a("p",[t._v("执行上下文周期：")]),t._v(" "),a("p",[t._v("1.创建:生成变量对象，建立作用域链(包含作用域链)，确定 this 指向")]),t._v(" "),a("p",[t._v("2.执行:变量赋值，函数引用，执行代码等")]),t._v(" "),a("p",[t._v("3.销毁")]),t._v(" "),a("div",{staticClass:"language-demo extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('var scope = "global scope";\nfunction checkscope(){\n    var scope = "local scope";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n1、执行全局代码，生成全局上下文，并且压入执行栈\nECStack=[\n     globalContext\n]\n2、全局上下文初始化\nglobalContext={\n     variableObject:[global,scope,checkscope],\n     this:globalContext.variableObject,\n     scopeChain:[globalContext.variableObject]\n}\n3、创建 checkscope 函数时生成内部属性 [[scope]],并将全局上下文作用域链存入其中\ncheckscope.[[scope]] = [\n     globalContext.variableObject\n]\n4、调用 checkscope 函数，创建函数上下文，压栈\nECStack=[\n     globalContext,\n     checkscopeContext\n]\n5、此时 checkscope 函数还未执行，进入执行上下文\n\n复制函数 [[scope]] 属性创建作用域链\n用 arguments 属性创建活动对象\n初始化变量对象，加入变量声明、函数声明、形参\n活动对象压入作用域链顶端\n\n    checkscopeContext = {\n        activationObject: {\n            arguments: {\n                length: 0\n            },\n            scope: undefined,\n            f: pointer, // reference to function f(),\n        },\n        scopeChain: [activationObject, globalContext.variableObject],\n        this: undefined\n    }\n6、checkscope 函数执行，对变量 scope 设值\n    checkscopeContext = {\n        activationObject: {\n            arguments: {\n                length: 0\n            },\n            scope: \'local scope\',\n            f: pointer, // reference to function f(),\n        },\n        scopeChain: [activationObject, globalContext.variableObject],\n        this: undefined\n    }\nf 函数被创建生成 [[scope]] 属性，并保存父作用域的作用域链\nf.[[scope]]=[\n     checkscopeContext.activationObject,\n     globalContext.variableObject\n]\n7、f 函数调用，生成 f 函数上下文，压栈\nECStack=[\n     globalContext,\n     checkscopeContext,\n     fContext\n]\n8、此时 f 函数还未执行，初始化执行上下文\n\n复制函数 [[scope]] 属性创建作用域链\n用 arguments 属性创建活动对象\n初始化变量对象，加入变量声明、函数声明、形参\n活动对象压入作用域链顶端\n\nfContext = {\n     activationObject: {\n            arguments: {\n                length: 0\n            },\n        },\n        scopeChain: [fContext.activationObject, checkscopeContext.activationObject, globalContext.variableObject],\n        this: undefined\n    }\n9、f 函数执行，沿着作用域链查找 scope 值，返回 scope 值\n10、f 函数执行完毕，f函数上下文从执行上下文栈中弹出\nECStack=[\n     globalContext,\n     checkscopeContext\n]\n11、checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出\nECStack=[\n     globalContext\n]\n\n\n')])])]),a("p",[t._v("ps1: 进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性\nps2: 变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作，可以认为同一个对象的不同生命周期。AO = VO + function parameters + arguments")]),t._v(" "),a("p",[t._v("代码执行两个阶段：代码预编译(确定作用域,创建 vo 变量对象)，代码执行(确定作用域链,vo->ao 激活对象)")]),t._v(" "),a("p",[t._v("柯里化:使用多层嵌套的闭包，为了参数的累加和延迟调用")]),t._v(" "),a("p",[t._v("调用栈：一个个的函数调用")]),t._v(" "),a("p",[t._v("闭包：外部环境可以访问内部函数的变量,使其不被销毁")]),t._v(" "),a("p",[t._v("内存管理：分配内存，使用内存，释放内存")]),t._v(" "),a("p",[t._v("垃圾回收：标记清除，引用计数")]),t._v(" "),a("h2",{attrs:{id:"es5-中的上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es5-中的上下文"}},[t._v("#")]),t._v(" es5 中的上下文")]),t._v(" "),a("p",[t._v("ES5 规范去除了 ES3 中变量对象和活动对象，以 词法环境组件（ LexicalEnvironment component） 和 变量环境组件（ VariableEnvironment component） 替代")]),t._v(" "),a("h4",{attrs:{id:"创建阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建阶段"}},[t._v("#")]),t._v(" 创建阶段")]),t._v(" "),a("p",[t._v("1.确定 this 的值，也被称为 This Binding")]),t._v(" "),a("p",[t._v("2.LexicalEnvironment（词法环境） 组件被创建")]),t._v(" "),a("p",[t._v("3.VariableEnvironment（变量环境） 组件被创建")]),t._v(" "),a("p",[t._v("创建全局上下文的词法环境使用 对象环境记录器 ,outer 值为 null;\n创建函数上下文的词法环境时使用 声明式环境记录器 ,outer 值为全局对象，或者为父级词法环境（作用域）")]),t._v(" "),a("h2",{attrs:{id:"对象和函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象和函数"}},[t._v("#")]),t._v(" 对象和函数")]),t._v(" "),a("p",[t._v("1.对象都是由函数创建的")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 仅仅是语法糖")]),t._v("\n类似于"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" arr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 也是语法趟")]),t._v("\n等价于"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" arr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Array")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("2.函数是一种对象")]),t._v(" "),a("p",[t._v("3.prototype\n每个函数都有一个默认属性"),a("code",[t._v("prototype")]),t._v(",它的值是一个对象('指向原型'而不是'原型')，默认只有一个属性 "),a("code",[t._v("constructor")]),t._v(" 指向函数自身")]),t._v(" "),a("p",[t._v("4."),a("code",[t._v("__proto__")]),t._v("\n每一个对象都有一个属性"),a("code",[t._v("__proto__")]),t._v("，指向创建这个对象的函数的 "),a("code",[t._v("prototype")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造函数的prototype和基于该构造函数的实例的`__proto__`都指向实例原型")]),t._v("\nobj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("函数的"),a("code",[t._v("prototype")]),t._v("也是对象，也有对应的"),a("code",[t._v("__proto__")]),t._v(",所有的对象都会指向 Object.prototype,Object.prototype."),a("strong",[t._v("proto")]),t._v("指向 null\n函数也是对象，也有"),a("code",[t._v("__proto__")]),t._v(".比如 Object，Array 等函数，都是由 Function 创建的，自然指向 Function.prototype\n比较特殊的：\nFunction."),a("strong",[t._v("proto")]),t._v("===Function.prototype")]),t._v(" "),a("p",[t._v("5.Instanceof 的判断队则是：沿着 A 的"),a("strong",[t._v("proto")]),t._v("这条线来找，同时沿着 B 的 prototype 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 true。如果找到终点还未重合，则返回 false")]),t._v(" "),a("h2",{attrs:{id:"作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),a("p",[t._v("函数创建的时候，会有一个内部属性[[scope]],包含了所有的父级变量对象")]),t._v(" "),a("p",[t._v("1.执行函数的时候，会先做一步准备，复制[[scope]]的属性创建作用域链")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("fnContext "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Scope")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" fnscope"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("scope"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("2.创建活动对象，加入形参，函数声明，变量声明")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("fnContext "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("AO")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("arguments")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("length")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("scope")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Scope")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" fnscope"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("scope"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("3.将活动对象压入作用域顶端")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("fnContext "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("AO")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("arguments")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("length")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("scope")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Scope")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("AO")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Scope"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("4.执行函数，更新 ao 的值")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("fnContext "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("AO")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("arguments")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("length")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("scope")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Scope")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("AO")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Scope"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("5.函数执行完毕上下文弹出")]),t._v(" "),a("h2",{attrs:{id:"任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务"}},[t._v("#")]),t._v(" 任务")]),t._v(" "),a("p",[t._v("同步任务：主线程执行栈\n异步任务：进入任务队列，不会立即执行")]),t._v(" "),a("p",[t._v("异步任务分为宏任务(macrotask)和微任务(microtask)")]),t._v(" "),a("h4",{attrs:{id:"宏任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务"}},[t._v("#")]),t._v(" 宏任务：")]),t._v(" "),a("p",[t._v("setTimeout(x 秒后放入宏任务队列)\nsetInterval\nI/O\n事件\npostMessage\nsetImmediate (Node.js，浏览器端该 API 已经废弃)\nrequestAnimationFrame\nUI 渲染")]),t._v(" "),a("h4",{attrs:{id:"微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微任务"}},[t._v("#")]),t._v(" 微任务：")]),t._v(" "),a("p",[t._v("Promise.then\nMutationObserver\nprocess.nextTick (Node.js)")]),t._v(" "),a("p",[t._v("每次主线程任务执行完毕后，会处理微任务队列，之后在处理宏任务队列")]),t._v(" "),a("h4",{attrs:{id:"new"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new"}},[t._v("#")]),t._v(" new")]),t._v(" "),a("p",[t._v("1.创建空对象 2.将空对象的"),a("strong",[t._v("proto")]),t._v("指向构造函数的 prototype 3.将空对象赋值给构造函数内部的 this，并执行构造函数逻辑 4.返回第一步创建的对象或者构造函数的显式返回值")]),t._v(" "),a("p",[t._v("o=new Constructor\n等价于\no = Object.create(Constructor.prototype);")]),t._v(" "),a("h4",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),a("p",[t._v("原型继承，构造函数继承，组合继承，寄生组合继承等")]),t._v(" "),a("h4",{attrs:{id:"高阶函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数"}},[t._v("#")]),t._v(" 高阶函数")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("函数作为参数")])]),t._v(" "),a("li",[a("p",[t._v("函数作为返回值")])])]),t._v(" "),a("h4",{attrs:{id:"纯函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#纯函数"}},[t._v("#")]),t._v(" 纯函数")]),t._v(" "),a("p",[t._v("必须有参数输入，相同的输入始终为相同的输出,且没有副作用。")]),t._v(" "),a("p",[t._v("优点：")]),t._v(" "),a("ol",[a("li",[t._v("可缓存数据")]),t._v(" "),a("li",[t._v("可测试")]),t._v(" "),a("li",[t._v("并行处理")])]),t._v(" "),a("p",[t._v("副作用：函数依赖外部的状态")]),t._v(" "),a("ol",[a("li",[t._v("配置")]),t._v(" "),a("li",[t._v("数据库")]),t._v(" "),a("li",[t._v("用户输入")])]),t._v(" "),a("h4",{attrs:{id:"柯里化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[t._v("#")]),t._v(" 柯里化")]),t._v(" "),a("p",[t._v("当一个函数有多个参数时，先传递一部分参数调用，然后返回一个新的函数接受剩余的参数，返回结果")]),t._v(" "),a("h4",{attrs:{id:"pointfree-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pointfree-模式"}},[t._v("#")]),t._v(" PointFree 模式")]),t._v(" "),a("p",[t._v("一种函数式编程的模式")]),t._v(" "),a("ol",[a("li",[t._v("不需要指定处理的数据")]),t._v(" "),a("li",[t._v("只需要合成运算过程(函数组合)")]),t._v(" "),a("li",[t._v("需要定义一些辅助的基本运算函数")])]),t._v(" "),a("h4",{attrs:{id:"functor-函子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#functor-函子"}},[t._v("#")]),t._v(" Functor 函子")]),t._v(" "),a("p",[t._v("特殊的容器，通过一个普通的对象来实现，该对象有 map 方法，可以允许一个函数对值进行处理")])])}),[],!1,null,null,null);a.default=e.exports}}]);