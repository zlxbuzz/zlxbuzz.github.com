(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{342:function(v,_,t){"use strict";t.r(_);var a=t(10),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[v._v("#")]),v._v(" 设计模式")]),v._v(" "),_("h2",{attrs:{id:"solid-原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#solid-原则"}},[v._v("#")]),v._v(" SOLID 原则")]),v._v(" "),_("p",[v._v("S 单一指责原则\nO 开放封闭原则: 扩展开放，修改封闭,需求变化时候通过扩展来解决\nL 李氏置换原则\nI 接口隔离原则\nD 依赖倒置原则: 函数返回尽量为接口类型")]),v._v(" "),_("h2",{attrs:{id:"工厂模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[v._v("#")]),v._v(" 工厂模式")]),v._v(" "),_("p",[v._v("当遇到一个 class 的时候，可以考虑采用工厂模式，定义一个工厂函数即可,返回一个 new 之后的对象")]),v._v(" "),_("p",[v._v("场景：")]),v._v(" "),_("ol",[_("li",[v._v("$")]),v._v(" "),_("li",[v._v("_createElementVNode")])]),v._v(" "),_("p",[v._v("优点： 1.通过创建一个个工厂函数，可以方便的传入参数去做同类的功能。 2.将对象的创建封装，实现封装和隔离。")]),v._v(" "),_("h2",{attrs:{id:"单例模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[v._v("#")]),v._v(" 单例模式")]),v._v(" "),_("h2",{attrs:{id:"原型模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[v._v("#")]),v._v(" 原型模式")]),v._v(" "),_("p",[v._v("主要考虑前端相关的原型。\nObject.create 将生成对象的"),_("strong",[v._v("proto")]),v._v("指向参数")]),v._v(" "),_("h2",{attrs:{id:"代理模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[v._v("#")]),v._v(" 代理模式")]),v._v(" "),_("p",[v._v("更加方便，更加安全,避免敏感信息")]),v._v(" "),_("p",[v._v("场景：")]),v._v(" "),_("ol",[_("li",[v._v("dom 事件代理")]),v._v(" "),_("li",[v._v("webpack devServer proxy")]),v._v(" "),_("li",[v._v("nginx 代理")]),v._v(" "),_("li",[v._v("vue3 数据响应")])]),v._v(" "),_("p",[v._v("Proxy 使用场景：")]),v._v(" "),_("ol",[_("li",[v._v("跟踪属性访问")]),v._v(" "),_("li",[v._v("隐藏属性")]),v._v(" "),_("li",[v._v("验证属性")]),v._v(" "),_("li",[v._v("记录实例")])]),v._v(" "),_("h2",{attrs:{id:"装饰器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#装饰器模式"}},[v._v("#")]),v._v(" 装饰器模式")]),v._v(" "),_("p",[v._v("动态添加功能，不影响原有的功能")]),v._v(" "),_("h2",{attrs:{id:"观察者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[v._v("#")]),v._v(" 观察者模式")]),v._v(" "),_("p",[v._v("一般包含一个主题， 多个观察者\n场景：")]),v._v(" "),_("ol",[_("li",[v._v("dom 事件，定时,Promise.then")]),v._v(" "),_("li",[v._v("vue 生命周期(data 相当于一个主题，watcher 相当于观察者。当 data 变化的时候，会 notify watcher，然后 watcher 就会 re-render 组件)")])]),v._v(" "),_("h3",{attrs:{id:"发布订阅模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式"}},[v._v("#")]),v._v(" 发布订阅模式")]),v._v(" "),_("p",[v._v("相对于观察者模式，多了一个主动触发操作")]),v._v(" "),_("p",[v._v("场景：1.自定义事件 2.postMessage 通讯")]),v._v(" "),_("p",[v._v("自定义事件需要及时销毁")]),v._v(" "),_("h2",{attrs:{id:"迭代器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式"}},[v._v("#")]),v._v(" 迭代器模式")]),v._v(" "),_("p",[v._v("ps: for 循环不是迭代器")]),v._v(" "),_("p",[v._v("顺序访问有序结构，不知道数据的长度和内部结构，高内聚，低耦合")]),v._v(" "),_("p",[v._v("场景：")]),v._v(" "),_("ol",[_("li",[v._v("有序结构")]),v._v(" "),_("li",[v._v("Symbol.iterator 和迭代器")]),v._v(" "),_("li",[v._v("遍历 dom 树")])]),v._v(" "),_("p",[v._v("** 迭代器的具有方法 next(),和 generator 函数一致")]),v._v(" "),_("p",[v._v("作用：")]),v._v(" "),_("ol",[_("li",[v._v("只要有迭代器，就可以用 for...of 来遍历获取子元素")]),v._v(" "),_("li",[v._v("解构，Array...from")]),v._v(" "),_("li",[v._v("创建 Map 和 Set")])]),v._v(" "),_("h2",{attrs:{id:"职责链模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#职责链模式"}},[v._v("#")]),v._v(" 职责链模式")]),v._v(" "),_("p",[v._v("多个角色处理一个流程")]),v._v(" "),_("p",[v._v("场景：")]),v._v(" "),_("ol",[_("li",[v._v("jquery 链式操作")]),v._v(" "),_("li",[v._v("promise")])])])}),[],!1,null,null,null);_.default=r.exports}}]);